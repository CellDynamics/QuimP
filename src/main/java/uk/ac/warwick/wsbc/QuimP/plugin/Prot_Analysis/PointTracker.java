package uk.ac.warwick.wsbc.QuimP.plugin.Prot_Analysis;

import java.awt.Polygon;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.vecmath.Point2i;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.sun.tools.javac.util.Pair;

import uk.ac.warwick.wsbc.QuimP.STmap;
import uk.ac.warwick.wsbc.QuimP.geom.TrackMap;
import uk.ac.warwick.wsbc.QuimP.utils.QuimPArrayUtils;

/**
 * Track point using tracking map generated by {@link uk.ac.warwick.wsbc.QuimP.geom.TrackMap}.
 * @author baniuk
 *
 */
public class PointTracker {
    private static final Logger LOGGER = LogManager.getLogger(PointTracker.class.getName());

    public PointTracker() {
    }

    /**
     * Track maxima across motility map as long as they fulfil criterion of amplitude.
     * 
     * @param mapCell holds all maps generated and saved by QuimP
     * @param drop the value (in x/100) while velocity remains above of the peak speed. E.g for
     * drop=1 all tracked points are considered (along positive motility), drop=0.5 stands for 
     * points that are above 0.5*peakval, where peakval is the value of found maximum.  
     * @param maximaFinder properly initialized object that holds maxima of motility map. 
     * All maxima are tracked
     * @return List of points tracked from every maximum point as long as they meet criterion.
     * Maximum point can be included in this list depending on setting of 
     * {@link uk.ac.warwick.wsbc.QuimP.geom.TrackMap.includeFirst} flag. Points for one tracking 
     * line are packed into PolygonRoi object. Those objects alternate -
     * backwardM1,forwardM1,backwardM2,forwardM2,... where Mx is maximum point. The size of list 
     * is 2*number of maxima.
     * It can contain only one point (maximum if set
     * {@link uk.ac.warwick.wsbc.QuimP.geom.TrackMap.includeFirst}) or empty polygon if no point accepted. 
     */
    public List<Polygon> trackMaxima(final STmap mapCell, double drop,
            final MaximaFinder maximaFinder) {
        int numFrames = mapCell.motMap.length;
        ArrayList<Polygon> ret = new ArrayList<>();
        // int[] indexes = new int[numFrames];
        int[] framesF = null;
        int[] framesB = null;
        Polygon maxi = maximaFinder.getMaxima(); // restore computed maxima
        double[] maxValues = maximaFinder.getMaxValues(); // max values in order of maxi
        TrackMap trackMap = new TrackMap(mapCell.originMap, mapCell.coordMap); // build tracking map
        trackMap.includeFirst = true; // include also initial point
        int[] tForward = null;
        int[] tBackward = null;
        int N = 0;
        // iterate through all maxima - take only indexes (x)
        for (int i = 0; i < maxi.npoints; i++) {
            int index = maxi.xpoints[i]; // considered index
            int frame = maxi.ypoints[i]; // considered frame
            LOGGER.trace("Max = [" + frame + "," + index + "]");
            // trace forward every index until end of time
            tForward = trackMap.trackForward(frame, index, numFrames - frame);
            framesF = trackMap.getForwardFrames(frame, numFrames - frame);
            // trace backward every index until end of time
            tBackward = trackMap.trackBackward(frame, index, frame);
            framesB = trackMap.getBackwardFrames(frame, frame);
            QuimPArrayUtils.reverseIntArray(framesB); // reverse have last frame on 0 index
                                                      // (important for Polygon creation)
            QuimPArrayUtils.reverseIntArray(tBackward);
            // check where is drop off - index that has velocity below drop
            double dropValue = maxValues[i] - maxValues[i] * drop;

            for (N = 0; N < tBackward.length; N++) {
                // frames[N] = frame + N + 1; // store number of current frame for tracked point +1
                // because max point is not included in tForward (tForward[0] is for frame+1)
                if (tBackward[N] >= 0) {
                    double val = (mapCell.motMap[framesB[N]][tBackward[N]]);
                    if (val < dropValue)
                        break;
                }
            }
            N = (--N < 0) ? 0 : N; // now end is the last index that fulfill criterion
            LOGGER.trace("tBackward frames:" + Arrays.toString(framesB));
            ret.add(new Polygon(tBackward, framesB, N));

            for (N = 0; N < tForward.length; N++) {
                // frames[N] = frame + N + 1; // store number of current frame for tracked point +1
                // because max point is not included in tForward (tForward[0] is for frame+1)
                if (tForward[N] >= 0) {
                    double val = (mapCell.motMap[framesF[N]][tForward[N]]);
                    if (val < dropValue)
                        break;
                }
            }
            N = (--N < 0) ? 0 : N; // now end is the last index that fulfill criterion
            LOGGER.trace("tForward frames:" + Arrays.toString(framesF));
            ret.add(new Polygon(tForward, framesF, N));
        }
        return ret;
    }

    /**
     * Find common points among polygons.
     * 
     * Check whether there are common points among polygons stored in List.
     * @param tracks List of polygons.
     * @return Polygon of size 0 when no intersection or polygons whose vertices are common for 
     * polygons in <tt>tracks</tt>. If there are vertexes shared among more than two polygons, they
     * appear only once in returned polygon.
     * <p><b>Warning</b><p>
     * Polygon of size 0 may contain x,y, arrays of size 4, only number of points is 0
     */
    public Polygon getIntersectionPoints(List<Polygon> tracks) {
        List<Polygon> tmpRet = new ArrayList<>();
        for (int i = 0; i < tracks.size() - 1; i++)
            for (int j = i + 1; j < tracks.size(); j++) {
                Polygon retPol = getIntersectionPoints(tracks.get(i), tracks.get(j));
                if (retPol.npoints != 0)
                    tmpRet.add(retPol); // add retained elements (common with p2)
            }
        // remove repeating vertexes
        List<Point2i> retP2i = QuimPArrayUtils.removeDuplicates(Polygon2Point2i(tmpRet));
        // convert from list of polygons to one polygon
        return Point2i2Polygon(retP2i);
    }

    /**
     * Check if p1 and p2 have common vertexes.
     * 
     * @param p1
     * @param p2
     * @return Polygon whose vertexes are those common for p1 and p2.
     */
    public Polygon getIntersectionPoints(Polygon p1, Polygon p2) {
        Polygon ret = new Polygon();
        List<Point2i> tmpRet = new ArrayList<>();
        List<Point2i> p1p = Polygon2Point2i(Arrays.asList(p1)); // polygon as list of points
        List<Point2i> p2p = Polygon2Point2i(Arrays.asList(p2)); // polygon as list of points
        // check if p1 and p2 have common elements
        p1p.retainAll(p2p);
        tmpRet.addAll(p1p); // add retained elements (common with p2)

        ret = Point2i2Polygon(tmpRet);
        return ret;
    }

    /**
     * Find common points among polygons. 
     * 
     * This method provides also parents of every common point. Parents are given as indexes of 
     * polygons in input list that have common vertex.
     * 
     * @param tracks List of polygons.
     * @return List of common points together with their parents List<Pair<Parents,Point>>.
     * If there is no common points the list is empty
     */
    public List<Pair<Point2i, Point2i>> getIntersectionParents(List<Polygon> tracks) {
        ArrayList<Pair<Point2i, Point2i>> ret = new ArrayList<>();
        for (int i = 0; i < tracks.size() - 1; i++)
            for (int j = i + 1; j < tracks.size(); j++) {
                Polygon retPol = getIntersectionPoints(tracks.get(i), tracks.get(j));
                for (int n = 0; n < retPol.npoints; n++) {
                    Pair<Point2i, Point2i> pairTmp = new Pair<Point2i, Point2i>(new Point2i(i, j),
                            new Point2i(retPol.xpoints[n], retPol.ypoints[n]));
                    ret.add(pairTmp);
                }
            }
        return ret;
    }

    /**
     * Convert list of Polygons to list of Points.
     * <p>
     * The difference is that for polygons points are kept in 1d arrays, whereas for Point2i they
     * are as separate points that allows object comparison.
     *  
     * @param list List of polygons to convert
     * @return List of points constructed from all polygons.
     */
    static public List<Point2i> Polygon2Point2i(List<Polygon> list) {
        List<Point2i> ret = new ArrayList<>();
        for (Polygon pl : list) { // every polygon
            for (int i = 0; i < pl.npoints; i++) // every point in it
                ret.add(new Point2i(pl.xpoints[i], pl.ypoints[i]));
        }
        return ret;
    }

    /**
     * Convert list of Points to list of Polygons.
     * <p>
     * The difference is that for polygons points are kept in 1d arrays, whereas for Point2i they
     * are as separate points that allows object comparison.
     *  
     * @param list List of points to convert
     * @return Polygon constructed from all points. This is 1-element list.
     */
    static public Polygon Point2i2Polygon(List<Point2i> list) {
        int x[] = new int[list.size()];
        int y[] = new int[list.size()];
        int l = 0;
        for (Point2i p : list) { // every point
            x[l] = p.getX();
            y[l] = p.getY();
            l++;
        }
        return new Polygon(x, y, list.size());
    }

}
