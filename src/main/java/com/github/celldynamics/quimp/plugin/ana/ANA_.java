package com.github.celldynamics.quimp.plugin.ana;

import java.awt.AWTEvent;
import java.awt.Checkbox;
import java.awt.Choice;
import java.awt.Color;
import java.awt.Polygon;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.github.celldynamics.quimp.CellStats;
import com.github.celldynamics.quimp.FormatConverter;
import com.github.celldynamics.quimp.FrameStatistics;
import com.github.celldynamics.quimp.Outline;
import com.github.celldynamics.quimp.OutlineHandler;
import com.github.celldynamics.quimp.QParams;
import com.github.celldynamics.quimp.QParamsQconf;
import com.github.celldynamics.quimp.QuimP;
import com.github.celldynamics.quimp.QuimpException;
import com.github.celldynamics.quimp.Vert;
import com.github.celldynamics.quimp.filesystem.ANAParamCollection;
import com.github.celldynamics.quimp.filesystem.DataContainer;
import com.github.celldynamics.quimp.filesystem.OutlinesCollection;
import com.github.celldynamics.quimp.filesystem.QconfLoader;
import com.github.celldynamics.quimp.geom.ExtendedVector2d;
import com.github.celldynamics.quimp.plugin.ecmm.ECMM_Mapping;
import com.github.celldynamics.quimp.plugin.ecmm.ECMp;
import com.github.celldynamics.quimp.plugin.ecmm.ODEsolver;
import com.github.celldynamics.quimp.registration.Registration;
import com.github.celldynamics.quimp.utils.QuimPArrayUtils;
import com.github.celldynamics.quimp.utils.QuimpToolsCollection;

import ij.IJ;
import ij.ImagePlus;
import ij.gui.DialogListener;
import ij.gui.GenericDialog;
import ij.gui.Overlay;
import ij.gui.PointRoi;
import ij.gui.PolygonRoi;
import ij.gui.Roi;
import ij.gui.YesNoCancelDialog;
import ij.measure.Measurements;
import ij.measure.ResultsTable;
import ij.plugin.Converter;
import ij.plugin.filter.Analyzer;
import ij.plugin.filter.PlugInFilter;
import ij.process.ImageProcessor;
import ij.process.ImageStatistics;

/**
 * Main ANA class implementing IJ PlugInFilter.
 * 
 * @author tyson
 */
public class ANA_ implements PlugInFilter, DialogListener {

  /**
   * The Constant LOGGER.
   */
  static final Logger LOGGER = LoggerFactory.getLogger(ANA_.class.getName());

  private QconfLoader qconfLoader;

  private OutlineHandler oh;
  private OutlineHandler outputH;
  private OutlineHandler ecmH;
  private OutlinesCollection outputOutlineHandlers; // output for new data file
  private Outline frameOneClone;
  private ECMM_Mapping ecmMapping;
  private ImagePlus orgIpl;
  private ImageProcessor orgIpr;
  private Overlay overlay;
  // outlines can be plotted separately. They are generated by Ana() and stored here
  private ArrayList<Roi> storedOuterROI; // outer outline for each frame
  private ArrayList<Roi> storedInnerROI; // inner outline for each frame

  private boolean fluoResultTable = false; // UI setting. Show results in IJ table at the end
  private boolean fluoResultTableAppend = false; // UI setting. Append result to IJ table.

  /**
   * ANA extends statistics generated by BOA by fluorescence related data.
   * 
   * <p>This is object that holds stats read from stQP file.
   */
  private FrameStatistics[] fluoStats;
  private ANAp anap;
  private static final int m =
          Measurements.AREA + Measurements.INTEGRATED_DENSITY + Measurements.MEAN;

  /**
   * Default constructor called always.
   */
  public ANA_() {
    storedOuterROI = new ArrayList<>();
    storedInnerROI = new ArrayList<>();
    anap = new ANAp();
  }

  /*
   * (non-Javadoc)
   * 
   * @see ij.plugin.filter.PlugInFilter#setup(java.lang.String, ij.ImagePlus)
   */
  @Override
  public int setup(String arg, ImagePlus imp) {
    about();
    if (imp == null) {
      IJ.error("Image required to take fluoresence measurments.");
      return DONE;
    }

    // System.out.println("flouIm dir: " +
    // imp.getOriginalFileInfo().directory);
    if (imp.getOriginalFileInfo() == null || imp.getOriginalFileInfo().directory.matches("")) {
      IJ.log("Error: Fluorescence file needs to be saved to disk");
      IJ.error("Please save your fluorescence image to file.");
      return DONE;
    }

    IJ.run("Appearance...", " menu=0"); // switch off interpolation of zoomed images

    orgIpl = imp;
    overlay = new Overlay();
    orgIpl.setOverlay(overlay);

    return DOES_8G + DOES_16 + NO_CHANGES;

  }

  /*
   * (non-Javadoc)
   * 
   * @see ij.plugin.filter.PlugInFilter#run(ij.process.ImageProcessor)
   */
  @Override
  public void run(ImageProcessor imageProcessor) {
    // validate registered user
    new Registration(IJ.getInstance(), "QuimP Registration");
    if (imageProcessor == null) {
      return;
    }
    IJ.showStatus("ANA Analysis");
    orgIpr = orgIpl.getProcessor();
    ECMp.plot = false;
    ecmMapping = new ECMM_Mapping(1);

    try {
      qconfLoader = new QconfLoader(null); // load file
      if (qconfLoader == null || qconfLoader.getQp() == null) {
        return; // failed to load exit
      }
      if (qconfLoader.getConfVersion() == QParams.QUIMP_11) { // old path
        runFromPaqp();
      } else if (qconfLoader.getConfVersion() == QParams.NEW_QUIMP) { // new path
        qconfLoader.getBOA(); // verify whether boa has been run (throws if not)
        qconfLoader.getEcmm(); // verify whether ecmm has been run (throws if not)
        qconfLoader.getStats(); // verify whether file contains stats
        if (qconfLoader.isANAPresent()) {
          YesNoCancelDialog ync;
          ync = new YesNoCancelDialog(IJ.getInstance(), "Overwrite",
                  "You are about to override previous ANA results. Is it ok?");
          if (!ync.yesPressed()) { // if no or cancel
            IJ.log("No changes done in input file.");
            return; // end}
          }
        }
        runFromQconf();
        IJ.log("The new data file " + qconfLoader.getQp().getParamFile().toString()
                + " has been updated by results of ECMM analysis.");
      } else {
        throw new IllegalStateException("QconfLoader returned unknown version of QuimP");
      }
      // post-plotting
      overlay = new Overlay();
      orgIpl.setOverlay(overlay);
      for (int f = 1; f < orgIpl.getStackSize(); f++) {
        orgIpl.setSlice(f);
        for (OutlineHandler ohTmp : outputOutlineHandlers.oHs) {
          Outline o = ohTmp.getOutline(f);
          if (o == null) {
            continue;
          }
          drawSamplePointsFloat(o, f);
          orgIpl.draw();
        }
      }
      // plotting outlines on separate image
      if (anap.plotOutlines) {
        ImagePlus orgIplclone = orgIpl.duplicate();
        orgIplclone.show();
        new Converter().run("RGB Color");
        Overlay overlay = new Overlay();
        orgIplclone.setOverlay(overlay);
        for (Roi r : storedOuterROI) {
          overlay.add(r);
        }
        for (Roi r : storedInnerROI) {
          overlay.add(r);
        }
        orgIplclone.draw();
      }

      // edd results to IJtable named Results - to allow Summarise
      if (fluoResultTable || fluoResultTableAppend) {
        if (qconfLoader.getConfVersion() == QParams.NEW_QUIMP) {
          ResultsTable rt;
          if (fluoResultTableAppend) { // get current table
            rt = Analyzer.getResultsTable();
          } else { // or create new
            rt = new ResultsTable();
            Analyzer.setResultsTable(rt);
          }
          // iterate over cells - all cells for this experiment are cumulated in one table
          for (CellStats cs : qconfLoader.getStats().getStatCollection()) {
            cs.addFluosToResultTable(rt, anap.channel);
          }
          rt.show("Results");
        } else {
          LOGGER.warn(
                  "Results can be shown in IJ table only if ANA is started with QCONF file format");
        }
      }
      IJ.log("ANA Analysis complete");
      IJ.showStatus("Finished");
      ecmMapping = null;
    } catch (Exception e) {
      LOGGER.debug(e.getMessage(), e);
      LOGGER.error("Problem with running ANA processing: " + e.getMessage());
    }
  }

  /**
   * Display standard QuimP about message.
   */
  private void about() {
    IJ.log(new QuimpToolsCollection().getQuimPversion());
  }

  /**
   * Main executive for ANA processing for QParamsQconf (new file version).
   * 
   * @throws QuimpException when OutlineHandler can not be read
   * @throws IOException when configuration can not be saved on disk
   */
  private void runFromQconf() throws IOException, QuimpException {
    LOGGER.debug("Processing from new file format");
    QParamsQconf qp = (QParamsQconf) qconfLoader.getQp();
    ANAParamCollection anaStates;
    OutlinesCollection ecmmState = qp.getLoadedDataContainer().ECMMState;
    outputOutlineHandlers = new OutlinesCollection(ecmmState.oHs.size());
    if (qp.getLoadedDataContainer().getANAState() == null) {
      // create ANA slots for all outlines
      anaStates = new ANAParamCollection(ecmmState.oHs.size()); // store ANA options for every cell
    } else {
      anaStates = qp.getLoadedDataContainer().getANAState(); // update old
    }
    for (int i = 0; i < ecmmState.oHs.size(); i++) { // go over all outlines
      // For compatibility, all methods have the same syntax (assumes that there is only one
      // handler)
      qp.setActiveHandler(i); // set current handler number.
      oh = ecmmState.oHs.get(i); // restore handler from ecmm
      anap = anaStates.aS.get(i); // get i-th ana parameters
      anap.setup(qconfLoader.getQp());

      // get stats stored in QCONF, they are extended by ANA (ChannelStat field)
      fluoStats = qconfLoader.getStats().sHs.get(i).framestat.toArray(new FrameStatistics[0]);

      investigateChannels(oh.indexGetOutline(0));// find first empty channel
      if (anap.noData && oh.getSize() == 1) {
        // only one frame, so no ECMM. set outline res to 2
        System.out.println("Only one frame. set marker res to 2");
        oh.indexGetOutline(0).setResolution(anap.oneFrameRes); // should be 2!!!
      }
      setImageScale();
      orgIpl.setSlice(qconfLoader.getQp().getStartFrame());
      if (!anaDialog()) {
        IJ.log("ANA cancelled");
        return;
      }
      anap.fluTiffs[anap.channel] = new File(orgIpl.getOriginalFileInfo().directory,
              orgIpl.getOriginalFileInfo().fileName);
      outputH = new OutlineHandler(oh); // copy input to output (ana will add fields to it)
      ana(); // fills outputH and ChannelStat in FrameStatistics
      FrameStatistics.write(fluoStats, anap.statFile, anap); // save fluoro to statFile for comp.
      CellStats statH = qconfLoader.getStats().sHs.get(i); // store fluoro in QCONF
      statH.framestat = new ArrayList<FrameStatistics>(Arrays.asList(fluoStats)); // store stats
      outputOutlineHandlers.oHs.add(i, new OutlineHandler(outputH)); // store actual result in cont
    }

    DataContainer dc = qp.getLoadedDataContainer();
    dc.ECMMState = outputOutlineHandlers; // assign ECMM container to global output
    dc.ANAState = anaStates;
    qp.writeParams(); // save global container
    // generate additional OLD files (stQP is generated in loop already), disabled #263, enabled 228
    if (QuimP.newFileFormat.get() == false) {
      FormatConverter foramtConv = new FormatConverter(qconfLoader);
      foramtConv.doConversion();
    }
  }

  /**
   * Main executive for ANA processing for QParams (old file version).
   * 
   * @throws QuimpException when OutlineHandler can not be read
   * @throws IOException when configuration can not be saved on disk
   */
  private void runFromPaqp() throws QuimpException, IOException {
    outputOutlineHandlers = new OutlinesCollection(1);
    oh = new OutlineHandler(qconfLoader.getQp());

    anap.setup(qconfLoader.getQp());
    fluoStats = FrameStatistics.read(anap.statFile);
    investigateChannels(oh.indexGetOutline(0));// find first empty channel

    if (anap.noData && oh.getSize() == 1) {
      // only one frame, so no ECMM. set outline res to 2
      System.out.println("Only one frame. set marker res to 2");
      oh.indexGetOutline(0).setResolution(anap.oneFrameRes); // should be 2!!!
    }

    setImageScale();
    orgIpl.setSlice(qconfLoader.getQp().getStartFrame());
    if (!oh.readSuccess) {
      throw new QuimpException("Could not read OutlineHandler");
    }
    if (!anaDialog()) {
      IJ.log("ANA cancelled");
      return;
    }
    System.out.println("CHannel: " + (anap.channel + 1));
    // qp.cortexWidth = ANAp.cortexWidthScale;
    anap.fluTiffs[anap.channel] =
            new File(orgIpl.getOriginalFileInfo().directory, orgIpl.getOriginalFileInfo().fileName);

    outputH = new OutlineHandler(oh.getStartFrame(), oh.getEndFrame());
    ana(); // fills outputH and ChannelStat in FrameStatistics

    anap.inFile.delete();
    anap.statFile.delete();
    outputH.writeOutlines(anap.outFile, qconfLoader.getQp().isEcmmHasRun());
    FrameStatistics.write(fluoStats, anap.statFile, anap);

    // ----Write temp files-------
    // File tempFile = new File(ANAp.outFile.getAbsolutePath() +
    // ".tempANA.txt");
    // outputH.writeOutlines(tempFile);
    // File tempStats = new File(ANAp.statFile.getAbsolutePath() +
    // ".tempStats.csv");
    // FluoStats.write(fluoStats, tempStats);
    // IJ.log("ECMM:137, saving to a temp file instead");
    // --------------------------

    IJ.showStatus("ANA Complete");
    IJ.log("ANA Complete");

    qconfLoader.getQp().cortexWidth = anap.getCortexWidthScale();
    qconfLoader.getQp().fluTiffs = anap.fluTiffs;
    qconfLoader.getQp().writeParams();
    outputOutlineHandlers.oHs.add(0, new OutlineHandler(outputH)); // for plotting purposes

  }

  private boolean anaDialog() {
    GenericDialog pd = new GenericDialog("ANA Dialog", IJ.getInstance());
    pd.addNumericField("Cortex width (\u00B5m)", anap.getCortexWidthScale(), 2);

    String[] channelC = { "1", "2", "3" };
    pd.addChoice("Save in channel", channelC, channelC[anap.channel]);
    pd.addCheckbox("Normalise to interior", anap.normalise);
    pd.addCheckbox("Sample at Ch" + (anap.useLocFromCh + 1) + " locations", anap.sampleAtSame);
    pd.addCheckbox("Clear stored measurements", false);
    pd.addCheckbox("New image with outlines? ", anap.plotOutlines);
    pd.addCheckbox("Copy results to IJ Table?", fluoResultTable);
    pd.addCheckbox("Append results to IJ Table?", fluoResultTableAppend);
    pd.addDialogListener(this);

    frameOneClone = (Outline) oh.indexGetOutline(0).clone(); // FIXME Change to copy constructor
    drawOutlineAsOverlay(frameOneClone, Color.RED);
    shrink(frameOneClone);
    drawOutlineAsOverlay(frameOneClone, Color.RED);
    pd.showDialog();

    // ANAp.cortexWidth = pd.getNextNumber();

    return pd.wasOKed();

  }

  /*
   * (non-Javadoc)
   * 
   * @see ij.gui.DialogListener#dialogItemChanged(ij.gui.GenericDialog, java.awt.AWTEvent)
   */
  @Override
  public boolean dialogItemChanged(GenericDialog gd, AWTEvent e) {

    if (gd.wasOKed()) {
      return true;
    }
    // add and append results can not be both active
    {
      Checkbox cb4 = (Checkbox) gd.getCheckboxes().elementAt(4); // move results to table
      Checkbox cb5 = (Checkbox) gd.getCheckboxes().elementAt(5); // append results to table
      if (e.getSource() == cb4) {
        if (cb4.getState()) {
          cb5.setState(false);
        }
      }
      if (e.getSource() == cb5) {
        if (cb5.getState()) {
          cb4.setState(false);
        }
      }
    }

    Checkbox cb = (Checkbox) gd.getCheckboxes().elementAt(2); // clear measurements
    Choice iob = (Choice) gd.getChoices().elementAt(0);
    if (cb.getState() && !anap.cleared) { // reset if clear measurments checked
      System.out.println("reset fluo");
      resetFluo();
      cb.setLabel("Measurments Cleared");
      IJ.log("All fluorescence measurements have been cleared");
      anap.channel = 0;
      iob.select(0);
      anap.cleared = true;
      return true;
    }

    anap.channel = gd.getNextChoiceIndex();
    anap.normalise = gd.getNextBoolean();
    anap.sampleAtSame = gd.getNextBoolean();
    anap.plotOutlines = ((Checkbox) gd.getCheckboxes().elementAt(3)).getState();
    // under multiple AAN run if there are many cells, remember only
    fluoResultTable = ((Checkbox) gd.getCheckboxes().elementAt(4)).getState();
    fluoResultTableAppend = ((Checkbox) gd.getCheckboxes().elementAt(5)).getState();
    double scale = gd.getNextNumber();
    anap.setCortextWidthScale(scale);
    if (anap.cleared) { // can't deselect
      cb.setState(true);
    }

    frameOneClone = (Outline) oh.indexGetOutline(0).clone(); // FIXME Change to copy constructor
    overlay.clear();
    drawOutlineAsOverlay(frameOneClone, Color.RED);
    shrink(frameOneClone);
    drawOutlineAsOverlay(frameOneClone, Color.RED);
    return true;// gd.invalidNumber();
  }

  /**
   * Reset fluo.
   */
  void resetFluo() {
    // reset all fluo back to -2 and st res to 2 if only one frame
    Outline o;
    for (int i = 0; i < oh.getSize(); i++) {
      o = oh.indexGetOutline(i);
      o.clearFluores();
      fluoStats[i].clearFluo();
    }

    if (oh.getSize() == 1) {
      // only one frame, so no ECMM. set outline res to 2
      System.out.println("Only one frame. set marker res to 2");
      oh.indexGetOutline(0).setResolution(anap.oneFrameRes);
    }

    // clear frame stats
    anap.noData = true;
    anap.channel = 0;
    anap.useLocFromCh = -1;
    anap.presentData[1] = 0;
    anap.presentData[2] = 0;
    anap.presentData[0] = 0;
    anap.fluTiffs[0] = new File("/");
    anap.fluTiffs[1] = new File("/");
    anap.fluTiffs[2] = new File("/");
  }

  /**
   * Sets the image scale.
   */
  void setImageScale() {
    orgIpl.getCalibration().frameInterval = anap.frameInterval;
    orgIpl.getCalibration().pixelHeight = anap.scale;
    orgIpl.getCalibration().pixelWidth = anap.scale;
  }

  /**
   * Main method for fluorescence measurements analysis. Adds also new stats to FrameStatistics.
   */
  private void ana() {
    Roi outerRoi;
    Roi innerRoi;
    Outline o1;
    Outline s1;
    Outline s2;

    IJ.showStatus("Running ANA (" + oh.getSize() + " frames)");
    for (int f = oh.getStartFrame(); f <= oh.getEndFrame(); f++) { // change i to frames
      IJ.log("Frame " + f);
      IJ.showProgress(f, oh.getEndFrame());

      orgIpl.setSlice(f);
      o1 = oh.getOutline(f);

      s1 = new Outline(o1);
      s2 = new Outline(o1);
      shrink(s2);

      // HACK for Du's embryoImage
      // shrink(s1);
      // s1.scale(14, 0.2);
      // ***

      // prepare overlay for current frame for plotting inner and outer outline
      overlay = new Overlay();
      orgIpl.setOverlay(overlay);
      outerRoi = o1.asFloatRoi(); // convert outlines to ROI
      innerRoi = s2.asFloatRoi();
      outerRoi.setPosition(f); // set for frame f
      outerRoi.setStrokeColor(Color.BLUE);
      innerRoi.setPosition(f);
      innerRoi.setStrokeColor(Color.RED);

      // store in object, will be plotted depending on user choice.
      storedInnerROI.add(innerRoi);
      storedOuterROI.add(outerRoi);
      overlay.add(outerRoi); // this is for real time preview during computations
      overlay.add(innerRoi);

      Polygon polyS2 = s2.asPolygon();
      setFluoStats(s1.asPolygon(), polyS2, f); // compute FrameStatistics for frame f

      // compute Vert.fluores field in Outline (FluoMeasurement[] fluores)
      // use sample points already there
      if (anap.sampleAtSame && anap.useLocFromCh != -1) {
        useGivenSamplepoints(o1);
      } else {

        ecmH = new OutlineHandler(1, 2);
        ecmH.setOutline(1, s1);
        ecmH.setOutline(2, s2);

        ecmH = ecmMapping.runByANA(ecmH, orgIpr, anap.getCortexWidthPixel());

        // copy flur data to o1 and save
        // some nodes may fail to migrate properly so need to check
        // tracknumbers match
        Vert v = o1.getHead();
        Vert v2 = ecmH.getOutline(2).getHead();

        while (v2.getTrackNum() != v.getTrackNum()) { // check id's match
          v = v.getNext();
          if (v.isHead()) {
            IJ.error("ANA fail");
            break;
            // return;
          }
        }

        int vertStart;
        do {
          v.setFluoresChannel(v2.fluores[0], anap.channel);
          v2 = v2.getNext();
          if (v2.isHead()) {
            break;
          }
          vertStart = v.getTrackNum();
          // find next vert in o1 that matches v2
          do {
            v = v.getNext();
            v.setFluoresChannel((int) Math.round(v.getX()), (int) Math.round(v.getY()), -1,
                    anap.channel); // map fail if -1. fix by interpolation
            if (vertStart == v.getTrackNum()) {
              System.out.println("ANA fail");
              return;
            }
          } while (v2.getTrackNum() != v.getTrackNum());
        } while (!v2.isHead());

        interpolateFailures(o1);
      }

      if (anap.normalise) {
        normalise2Interior(o1, f);
      }
      outputH.save(o1, f);
    }
  }

  private void shrink(Outline o) {
    // shrink outline
    o.scale(anap.getCortexWidthPixel(), -anap.stepRes, anap.angleTh, anap.freezeTh);

    this.markFrozenNodesNormal(frameOneClone);
    orgIpl.draw();
    o.unfreezeAll();
  }

  private void markFrozenNodesNormal(Outline o) {
    float[] x;
    float[] y;
    ExtendedVector2d norm;
    PolygonRoi pr;
    Vert v = o.getHead();
    do {
      if (v.isFrozen()) {
        overlay.setStrokeColor(Color.RED);
        norm = new ExtendedVector2d(v.getX(), v.getY());
        norm.addVec(v.getNormal());
        // norm.addVec(new Vect2d(1,1));

        x = new float[2];
        y = new float[2];

        x[0] = (float) v.getX();
        x[1] = (float) norm.getX();
        y[0] = (float) v.getY();
        y[1] = (float) norm.getY();
        pr = new PolygonRoi(x, y, 2, Roi.POLYGON);
        overlay.add(pr);
      }

      v = v.getNext();
    } while (!v.isHead());
  }

  /**
   * Compute statistics.
   * 
   * <p>Update {@link com.github.celldynamics.quimp.plugin.ana.ChannelStat} in
   * {@link com.github.celldynamics.quimp.FrameStatistics}
   * 
   * @param outerPoly outerPoly
   * @param innerPoly innerPoly
   * @param f frame
   */
  private void setFluoStats(Polygon outerPoly, Polygon innerPoly, int f) {

    int store = f - anap.startFrame; // frame to index
    // System.out.println("store: " + store);
    fluoStats[store].frame = f;

    orgIpr.setRoi(outerPoly);
    // this does NOT scale to image
    ImageStatistics is = ImageStatistics.getStatistics(orgIpr, m, null);
    double outerAreaRaw = is.area;
    fluoStats[store].channels[anap.channel].totalFluor = is.mean * outerAreaRaw;
    fluoStats[store].channels[anap.channel].meanFluor = is.mean;

    orgIpr.setRoi(innerPoly);
    is = ImageStatistics.getStatistics(orgIpr, m, null);

    fluoStats[store].channels[anap.channel].innerArea =
            QuimpToolsCollection.areaToScale(is.area, anap.scale);
    fluoStats[store].channels[anap.channel].totalInnerFluor = is.mean * is.area;
    fluoStats[store].channels[anap.channel].meanInnerFluor = is.mean;

    fluoStats[store].channels[anap.channel].cortexArea =
            fluoStats[store].area - fluoStats[store].channels[anap.channel].innerArea; // scaled
    fluoStats[store].channels[anap.channel].totalCorFluo =
            fluoStats[store].channels[anap.channel].totalFluor
                    - fluoStats[store].channels[anap.channel].totalInnerFluor;
    fluoStats[store].channels[anap.channel].meanCorFluo =
            fluoStats[store].channels[anap.channel].totalCorFluo / (outerAreaRaw - is.area);

    fluoStats[store].channels[anap.channel].percCortexFluo =
            (fluoStats[store].channels[anap.channel].totalCorFluo
                    / fluoStats[store].channels[anap.channel].totalFluor) * 100;
    fluoStats[store].channels[anap.channel].cortexWidth = anap.getCortexWidthScale();
  }

  private void normalise2Interior(Outline o, int f) {
    // interior mean fluorescence is used to normalse membrane measurments
    int store = f - anap.startFrame; // frame to index
    Vert v = o.getHead();
    do {
      v.fluores[anap.channel].intensity = v.fluores[anap.channel].intensity
              / fluoStats[store].channels[anap.channel].meanInnerFluor;
      v = v.getNext();
    } while (!v.isHead());

  }

  private void drawOutlineAsOverlay(Outline o, Color c) {
    Roi r = o.asFloatRoi();
    if (r.subPixelResolution()) {
      System.out.println("is sub pixel");
    } else {
      System.out.println("is not sub pixel");
    }
    overlay.setStrokeColor(c);
    overlay.add(r);
    orgIpl.updateAndDraw();
  }

  private void investigateChannels(Outline o) {
    // flu maps
    int firstEmptyCh = -1;
    int firstFullCh = -1;

    anap.presentData = new int[3];
    anap.noData = true;

    Vert v = o.getHead();
    for (int i = 0; i < 3; i++) {
      if (v.fluores[i].intensity == -2) { // no data
        anap.presentData[i] = 0;
        if (firstEmptyCh == -1) {
          firstEmptyCh = i;
        }
      } else {
        anap.presentData[i] = 1;
        IJ.log("Data exists in channel " + (i + 1));
        anap.noData = false;
        if (firstFullCh == -1) {
          firstFullCh = i;
        }
        // anap.setCortextWidthScale(fluoStats[0].channels[i].cortexWidth);
      }
    }

    if (QuimPArrayUtils.sumArray(anap.presentData) == 3) {
      firstEmptyCh = 0;
    }

    if (anap.noData) {
      anap.channel = 0;
      IJ.log("No previous sample points available.");
      anap.useLocFromCh = -1;
    } else {
      anap.channel = firstEmptyCh;
      IJ.log("Sample points from channel " + (firstFullCh + 1) + " available.");
      anap.useLocFromCh = firstFullCh;
    }

    v = o.getHead();
    for (int i = 0; i < 3; i++) {
      if (v.fluores[i].intensity != -2) {
        anap.setCortextWidthScale(fluoStats[0].channels[i].cortexWidth);
      }
    }
  }

  private void interpolateFailures(Outline o) {
    Vert v = o.getHead();
    Vert last;
    Vert nex;
    double disLtoN; // distance last to nex
    double disLtoV; // distance last to V
    double ratio;
    double intensityDiff;
    boolean fail;
    int firstID;
    do {
      fail = false;
      if (v.fluores[anap.channel].intensity == -1) {
        IJ.log("\tInterpolated failed node intensity (position: " + v.coord + ")");
        // failed to map - interpolate with last/next successful

        last = v.getPrev();
        firstID = last.getTrackNum();
        while (last.fluores[anap.channel].intensity == -1) {
          last = last.getPrev();
          if (last.getTrackNum() == firstID) {
            IJ.log("Could not interpolate as all nodes failed");
            v.fluores[anap.channel].intensity = 0;
            fail = true;
          }
        }

        nex = v.getNext();
        firstID = nex.getTrackNum();
        while (nex.fluores[anap.channel].intensity == -1) {
          nex = nex.getNext();
          if (nex.getTrackNum() == firstID) {
            IJ.log("Could not interpolate as all nodes failed");
            v.fluores[anap.channel].intensity = 0;
            fail = true;
          }
        }

        if (fail) {
          v = v.getNext();
          continue;
        }

        disLtoN = ExtendedVector2d.lengthP2P(last.getPoint(), nex.getPoint());
        disLtoV = ExtendedVector2d.lengthP2P(last.getPoint(), v.getPoint());
        ratio = disLtoV / disLtoN;
        if (ratio > 1) {
          ratio = 1;
        }
        if (ratio < 0) {
          ratio = 0;
        }
        intensityDiff = (nex.fluores[anap.channel].intensity - last.fluores[anap.channel].intensity)
                * ratio;
        v.fluores[anap.channel].intensity = last.fluores[anap.channel].intensity + intensityDiff;
        if (v.fluores[anap.channel].intensity < 0 || v.fluores[anap.channel].intensity > 255) {
          IJ.log("Error. Interpolated intensity out of range. Set to zero.");
          v.fluores[anap.channel].intensity = 0;
        }
      }

      v = v.getNext();
    } while (!v.isHead());
  }

  private void drawSamplePointsFloat(Outline o, int frame) {
    float x;
    float y;
    PointRoi pr;
    Vert v = o.getHead();
    do {
      x = (float) v.fluores[anap.channel].x;
      y = (float) v.fluores[anap.channel].y;
      pr = new PointRoi(x + 0.5, y + 0.5);
      pr.setPosition(frame);
      overlay.add(pr);
      v = v.getNext();
    } while (!v.isHead());
  }

  /**
   * Add fluorescence data to outline.
   * 
   * @param o1 outline to complete o1.fluores[channel] data
   */
  private void useGivenSamplepoints(Outline o1) {
    int x;
    int y;

    Vert v = o1.getHead();
    do {
      x = (int) v.fluores[anap.useLocFromCh].x;
      y = (int) v.fluores[anap.useLocFromCh].y;
      // use the same sampling as for ECMM solving
      v.fluores[anap.channel].intensity = ODEsolver.sampleFluo(orgIpr, x, y);
      v.fluores[anap.channel].x = x;
      v.fluores[anap.channel].y = y;
      v = v.getNext();
    } while (!v.isHead());

  }
}
