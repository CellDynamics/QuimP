/*
 * //!>
 * 
 * @startuml doc-files/stats_2_UML.png
 * actor user
 * user -> user : //create DataContainer dt//
 * user -> StatsCollection : //<create>//
 * activate StatsCollection 
 * StatsCollection --> user : pointer
 * StatsCollection -> StatsCollection : ""copyFromCellStat(CellStatsEval)""
 * note left
 * Populate stats
 * to serializable container
 * end note
 * user -> Serializer : //<create>//, ""dt""
 * activate Serializer
 * user -> Serializer : ""save()""
 * @enduml
 * 
 * //!<
 */

/*
 * //!>
 * @startuml doc-files/stats_1_UML.png
 * CellStatsEval *-- "1" CellStats
 * CellStats o-- "1..*" FrameStatistics
 * StatsCollection o-- "1..*" CellStats
 * 
 * note top of CellStatsEval
 * Exchange class
 * Writes files and delivers
 * stat ""CellStats"" object.
 * end note
 * note top of StatsCollection : Keep ""CellStats"" for every cell\nin DataContainer.
 * note left of CellStats
 * Keep stats for every cell
 * in ""FrameStatistics""
 * for all frames
 * This representation is used
 * by **NEW** file format
 * end note 
 * note left of FrameStatistics
 * Keep numeric data for every
 * frame for one cell.
 * This representation is used by
 * **old** file format
 * end note
 * 
 * class CellStats{
 * +List<FrameStatistics>
 * }
 * class CellStatsEval {
 * -CellStats
 * }
 * class StatsCollection {
 * +List<CellStats>
 * }
 * @enduml
 * 
 * //!<
 */

/*
 * //!>
 * @startuml doc-files/stats_3_UML.png
 * actor user
 * user-->BOA: finish()
 * note left: Ending analysis
 * BOA->Nest:analyse(ImageProcessor)
 * loop All SnakeHandlers
 * Nest->Nest: convert SnakeHandler
 * Nest-->CellStatsEval: <<create>>(OutlineHandler)
 * activate CellStatsEval
 * loop All frames
 * CellStatsEval->CellStatsEval:record
 * note left
 * Compute stats for
 * each frame
 * end note
 * alt New format
 * CellStatsEval->CellStatsEval:build
 * note left
 * Build CellStats
 * objects
 * end note
 * else Old format
 * CellStatsEval->CellStatsEval:write
 * CellStatsEval->CellStatsEval:build
 * end
 * end
 * CellStatsEval-->Nest:store in List<CellStatsEval>
 * deactivate CellStatsEval
 * end
 * 
 * Nest-->BOA:List<CellStatsEval>
 * group Fill container
 * BOA->BOA:copyFromCellStat
 * note left: See //stats_2_UML//
 * end
 * @enduml
 * 
 * //!<
 */

/*
 * //!>
 * @startuml doc-files/datacontainer_UML.png
 * DataContainer o--"0..1" BOAState
 * DataContainer o--"0..1" OutlinesCollection
 * DataContainer o--"0..1" ANAParamCollection
 * DataContainer o--"0..1" StatsCollection
 * DataContainer o--"0.." STmap
 * BOAState *--"1" BOAp
 * BOAState *--"1" ParamList
 * BOAState *--"1.." SegParam
 * BOAState *--"1.." SnakePluginList
 * BOAState o--"1" Nest
 * OutlinesCollection o--"0..1" OutlineHandler
 * OutlineHandler o--"0..1" Outline
 * ANAParamCollection o--"0.." ANAp
 * STmap *--"1..3" FluoMap
 * CellStats o-- "1..*" FrameStatistics
 * StatsCollection o-- "1..*" CellStats
 * DataContainer..|> IQuimpSerialize
 * BOAState ..|> IQuimpSerialize
 * OutlinesCollection ..|> IQuimpSerialize
 * OutlineHandler ..|> IQuimpSerialize
 * ANAParamCollection ..|> IQuimpSerialize
 * STmap ..|> IQuimpSerialize
 * StatsCollection ..|> IQuimpSerialize
 * @enduml
 * 
 * //!<
 */

/**
 * This is the main package.
 * 
 * Below there are fragments of QuimP architecture.
 * <h1>QCONF file description</h1> The content of QCONF file is strictly related to the QuimP
 * architecture. User is supposed to read JavaDoc documentation for particular classes to find what
 * data are kept there. The starting point is the main container
 * {@link com.github.celldynamics.quimp.filesystem.DataContainer} that covers the whole QCONF
 * structure.
 * Briefly relations among classes used by
 * {@link com.github.celldynamics.quimp.filesystem.DataContainer}
 * are:<br>
 * <img src="doc-files/datacontainer_UML.png"/><br>
 * 
 * <h1>Architecture</h1>
 * <h2>Generating statistic files</h2>
 * 
 * Statistics generated by QuimP are related to cell shape and fluorescence distribution along cell
 * cortex. They are stored in <i>stQP.csv</i> and <i>QCONF</i> files but they are built on different
 * stages of processing. The general class relationship is as follows:<br>
 * <img src="doc-files/stats_1_UML.png"/><br>
 * {@link com.github.celldynamics.quimp.CellStatsEval} depending how it is created, writes
 * statistics
 * to
 * disk as stQP files or only computes them internally (they are computed as well for first case).
 * They can be obtained by calling {@link com.github.celldynamics.quimp.CellStatsEval#getStatH()}
 * which
 * provides {@link com.github.celldynamics.quimp.CellStats} object that holds statistics for one
 * cell for
 * all frames (as List of {@link com.github.celldynamics.quimp.FrameStatistics} objects.
 * {@link com.github.celldynamics.quimp.FrameStatistics} are computed by
 * {@link com.github.celldynamics.quimp.CellStatsEval} and they are used by old path (paQP) to write
 * stQP file. {@link com.github.celldynamics.quimp.CellStats} is wrapper to
 * <tt>FrameStatistics[]</tt> that delivers List of
 * {@link com.github.celldynamics.quimp.FrameStatistics} (stats for subsequent frames for one cell)
 * to {@link com.github.celldynamics.quimp.filesystem.StatsCollection} which gather statistics for
 * all cells in experiments and then is serialized.
 * DataContainer
 * holds List of {@link com.github.celldynamics.quimp.CellStats} for every cell in experiment.
 * Fitting
 * statistic object into {@link com.github.celldynamics.quimp.filesystem.DataContainer}:
 * <br>
 * <img src="doc-files/stats_2_UML.png"/>
 * <br>
 * Relevant part of code:<br>
 * 
 * <pre>
 * <code>
 *     DataContainer dt = new DataContainer(); // create container
 *     dt.BOAState = qState; // assign boa state to correct field
 *     dt.Stats = new StatsCollection();
 *     dt.Stats.copyFromCellStat(ret); // StatsHandler is initialized here.
 *     n = new Serializer<>(dt, quimpInfo);
 *     if (qState.boap.savePretty) // set pretty format if configured
 *         n.setPretty();
 *     n.save(qState.boap.deductNewParamFileName());
 * </code>
 * </pre>
 * 
 * Some general dependencies:
 * <br>
 * <img src="doc-files/stats_3_UML.png"/>
 * <br>
 * 
 * <h1>Code rules</h1>
 * 
 * <h1>Other</h1>
 * <h2>Nondeterministic results</h2>
 * 
 * Many algorithms implemented in QuimP related to either Snake or Outline perform node removing
 * from {@link com.github.celldynamics.quimp.PointsList} wrapped by
 * {@link com.github.celldynamics.quimp.Shape}. If head node (can be
 * {@link com.github.celldynamics.quimp.Vert} or {@link com.github.celldynamics.quimp.Node} object)
 * is
 * removed, new head is chosen randomly between next and previous element. This affects end result
 * making it nondeterministic, especially for iterative shrinking like e.g.
 * {@link com.github.celldynamics.quimp.Outline#scale(double, double, double, double)}
 * or scaling in {@link com.github.celldynamics.quimp.Snake}. To make testing possible, threshold
 * level
 * defined in {@link com.github.celldynamics.quimp.Shape} is static and private to avoid accidental
 * modification.
 * 
 * <p>This filed can be overridden in setUp and restored in after:
 * 
 * <pre>
 * <code>
 * Field f = Shape.class.getDeclaredField("threshold");
 * f.setAccessible(true);
 * f.setDouble(Shape.class, 1.0);
 * </code>
 * </pre>
 * 
 * <h2>Restoring Snake parameters</h2>
 * 
 * If Snake is given as pure list of points some remaining internal parameters can be restored as
 * follows:
 * 
 * <pre>
 * <code>
 * Constrictor constrictor = new Constrictor();
 * for (SnakeHandler sh : nest.getHandlers()) {
 *   for (int f = sh.getStartFrame(); f <= sh.getEndFrame(); f++) {
 *     sh.getBackupSnake(f).calcCentroid(); // called in Shape constructor
 *     sh.getBackupSnake(f).setPositions();
 *     sh.getBackupSnake(f).updateNormales(true);
 *     sh.getBackupSnake(f).getBounds(); // called in Snake constructor
 *
 *     sh.getStoredSnake(f).calcCentroid();
 *     sh.getStoredSnake(f).setPositions();
 *     sh.getStoredSnake(f).updateNormales(true);
 *     sh.getStoredSnake(f).getBounds();
 *
 *     constrictor.constrict(sh.getStoredSnake(f), ip.getStack().getProcessor(f));
 *     constrictor.constrict(sh.getBackupSnake(f), ip.getStack().getProcessor(f));
 *   }
 *   sh.getLiveSnake().calcCentroid();
 *   sh.getLiveSnake().setPositions();
 *   sh.getLiveSnake().updateNormales(true);
 *   sh.getLiveSnake().getBounds();
 *   constrictor.constrict(sh.getLiveSnake(), ip.getStack().getProcessor(sh.getStartFrame()));
 * }
 * </code>
 * </pre>
 * 
 * Some of them are computed in constructors.
 */
package com.github.celldynamics.quimp;
